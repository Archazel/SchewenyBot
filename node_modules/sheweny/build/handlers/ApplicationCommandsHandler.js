"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ApplicationCommandsHandler = void 0;
const collection_data_1 = require("collection-data");
const ShewenyClient_1 = require("../ShewenyClient");
const path_1 = require("path");
const readDirFiles_1 = require("../util/readDirFiles");
const events_1 = require("events");
/**
 * Create Application Command handler
 * @class Application Command Handler
 */
class ApplicationCommandsHandler extends events_1.EventEmitter {
    /**
     * @constructor
     * @param {ShewenyClient | Client} client - The client
     */
    constructor(client, directory, loadAll) {
        super();
        if (!client)
            throw new ReferenceError("Client must be provided for use Application handler.");
        if (!directory)
            throw new TypeError("Directory must be provided.");
        this.dir = directory;
        this.client = client;
        this.applicationCommands =
            client instanceof ShewenyClient_1.ShewenyClient ? client.commands.interaction : undefined;
        if (loadAll?.loadAll)
            this.loadAllAndRegister(loadAll?.guildId);
        if (client && client instanceof ShewenyClient_1.ShewenyClient)
            client.handlers.applicationCommands = this;
    }
    /**
     * Load all commands and register them to a collection.
     * @public
     * @async
     * @param {string} [guildId] - The guild to register command
     * @returns {Promise<CollectionDjs<string, ApplicationCommandDjs<{}>> | CollectionDjs<string, ApplicationCommandDjs<{ guild: GuildResolvable; }>> | undefined>} The application commands
     */
    async loadAllAndRegister(guildId) {
        const commands = await this.loadAll();
        return this.registerCommands(commands, guildId);
    }
    /**
     * Load all commands and register them to a collection.
     * @public
     * @async
     * @returns {Promise<Collection<string, ApplicationCommand>>} The collection of commands
     */
    async loadAll() {
        const commands = new collection_data_1.Collection();
        const baseDir = path_1.join(require.main.path, this.dir);
        const cmds = await readDirFiles_1.readDirAndPush(baseDir);
        for (const cmdPath of cmds) {
            const commandImport = await Promise.resolve().then(() => require(cmdPath));
            const key = Object.keys(commandImport)[0];
            const Command = commandImport[key];
            if (!Command)
                continue;
            const instance = new Command(this.client);
            if (!instance.data.name)
                continue;
            instance.path = cmdPath;
            commands.set(instance.data.name, instance);
        }
        if (this.client instanceof ShewenyClient_1.ShewenyClient)
            this.client.commands.interaction = commands;
        return commands;
    }
    /**
     * Get an array of application commands configuration for register it
     * @public
     * @param {Collection<string, ApplicationCommand>} applicationCommands - The application commands
     * @returns {ApplicationCommandData[]}
     */
    getData(applicationCommands) {
        const data = [];
        applicationCommands.forEach((e) => data.push(e.data));
        return data;
    }
    /**
     * Register application commands
     * @public
     * @async
     * @param {Collection<string, ApplicationCommand>} applicationCommands - The application commands to register
     * @param {string} [guildId] - The guild to register context menus
     * @returns {Promise<CollectionDjs<string, ApplicationCommand<{}>> | CollectionDjs<string, ApplicationCommand<{ guild: GuildResolvable; }>> | undefined>} The application commands
     */
    async registerCommands(applicationCommands = this
        .applicationCommands, guildId) {
        if (this.client instanceof ShewenyClient_1.ShewenyClient)
            await this.client.awaitReady();
        if (!applicationCommands)
            throw new ReferenceError("ApplicationCommand Collection must be provided for use Application Command handler.");
        const data = this.getData(applicationCommands);
        if (data && data.length > 0) {
            return guildId
                ? this.client.application?.commands.set(data, guildId)
                : this.client.application?.commands.set(data);
        }
        return undefined;
    }
    /**
     * Create a Application Command
     * @public
     * @async
     * @param {Command} applicationCommand - The application command to register
     * @param {string} [guildId] - The guild to register command
     * @returns {Promise<CollectionDjs<string, ApplicationCommandDjs<{}>> | CollectionDjs<string, ApplicationCommandDjs<{ guild: GuildResolvable; }>> | undefined>} The application commands
     */
    async createCommand(applicationCommand, guildId) {
        if (this.client instanceof ShewenyClient_1.ShewenyClient)
            await this.client.awaitReady();
        return guildId
            ? this.client.application?.commands.create(applicationCommand.data, guildId)
            : this.client.application?.commands.create(applicationCommand.data);
    }
    /**
     * Edit a application command
     * @public
     * @async
     * @param {ApplicationCommandResolvable} oldCommand - The command to edit
     * @param {ApplicationCommand} newCommand - The new application command to edit
     * @param {string} [guildId] - The guild to edit command
     * @returns {Promise<ApplicationCommand<{}> | ApplicationCommand<{ guild: GuildResolvable }> | undefined>} The application commands
     */
    async editCommand(oldCommand, newCommand, guildId) {
        if (this.client instanceof ShewenyClient_1.ShewenyClient)
            await this.client.awaitReady();
        return guildId
            ? this.client.application?.commands.edit(oldCommand, newCommand.data, guildId)
            : this.client.application?.commands.edit(oldCommand, newCommand.data);
    }
    /**
     * Delete application command
     * @public
     * @async
     * @param {ApplicationCommandResolvable} command - The command to delete
     * @param {string} [guildId] - The guild to delete command
     * @returns {Promise<ApplicationCommandDjs<{}> | ApplicationCommandDjs<{ guild: GuildResolvable }> | undefined>} Delete function
     */
    async deleteCommand(command, guildId) {
        if (this.client instanceof ShewenyClient_1.ShewenyClient)
            await this.client.awaitReady();
        return guildId
            ? this.client.application?.commands.delete(command, guildId)
            : this.client.application?.commands.delete(command);
    }
    /**
     * Delete all application commands
     * @public
     * @async
     * @param {string} [guildId] - The guild to delete commands
     * @returns {Promise<CollectionDjs<string, ApplicationCommandDjs<{}>> | CollectionDjs<string, ApplicationCommandDjs<{ guild: GuildResolvable; }>> | undefined>} The application commands
     */
    async deleteAllCommands(guildId) {
        return guildId
            ? this.client.application?.commands.set([], guildId)
            : this.client.application?.commands.set([]);
    }
}
exports.ApplicationCommandsHandler = ApplicationCommandsHandler;
